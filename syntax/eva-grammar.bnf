// ----------------------------------------
// Lexical grammar (tokens)

%lex

%%

\s+                /* skip whitespace */ return "";
\"[^\"]*\"         return "STRING"
[\-]?\d+           return "NUMBER"
'true'|'false'     return "BOOLEAN"
'null'             return "NULL"
'begin'            return "BEGIN"
'var'              return "VAR"
'if'               return "IF"
'while'            return "WHILE"
'set'              return "ASSIGN"
[=<>]+             return "OPERATOR"
[+\-*/\w]+         return "IDENTIFIER"

/lex

// ----------------------------------------
// Syntactic grammar (BNF)

%{
use std::sync::Arc;
use core::fmt::Debug;

#[derive(Debug,PartialEq,Clone)]
pub enum Expr {
  Literal(Value),
  BinaryExpression(String, Box<Expr>, Box<Expr>),
  VariableDeclaration(String, Box<Expr>),
  Identifier(String),
  BlockStatement(Vec<Expr>),
  Assignment(String, Box<Expr>),
  IfExpression(Box<Expr>, Box<Expr>, Box<Expr>),
  WhileStatement(Box<Expr>, Box<Expr>),
  CallExpression(String, Vec<Expr>)
}

pub struct Func {
  func: Arc<dyn Fn(Vec<Value>) -> Result<Value, String>> // TODO
}

impl Func {
  pub fn new<F>(f: F) -> Self 
  where 
    F: Fn(Vec<Value>) -> Result<Value, String> + 'static
  {
    Func {
      func: Arc::new(f)
    }
  }

  pub fn call(&self, args: Vec<Value>) -> Result<Value, String> {
    (self.func)(args)
  }
}

impl PartialEq for Func {
  fn eq(&self, _: &Self) -> bool {
      false
  }
}

impl Debug for Func {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
      write!(f, "Function")
  }
}

impl Clone for Func {
  fn clone(&self) -> Self {
    Func {
        func: Arc::clone(&self.func)
    }
  }
}

#[derive(Debug,PartialEq,Clone)]
pub enum Value {
  Int(isize),
  Str(String),
  Null,
  Boolean(bool),
  Function(Func)
}

type TResult = Expr;

%}

%%

Expression
    : Literal { 
      |$1: Value| -> Expr;
      $$ = Expr::Literal($1) 
    }
    | IDENTIFIER {
      || -> Expr;
      $$ = Expr::Identifier(yytext.to_string())
    }
    | SExpr { $$ = $1 }
    ;

Literal
    : NUMBER {
      || -> Value;
      $$ = Value::Int(yytext.parse::<isize>().unwrap())
    }
    | STRING {
      || -> Value;
      $$ = Value::Str(yytext.to_string())
    }
    | BOOLEAN {
      || -> Value;
      $$ = Value::Boolean(yytext == "true")
    }
    | NULL {
      || -> Value;
      $$ = Value::Null
    }
    ;

ExpressionsList
  : ExpressionsList Expression {
    |$1: Vec<Expr>, $2: Expr | -> Vec<Expr>;
    $1.push($2);
    $$ = $1
  }
  | /* empty */ {
    || -> Vec<Expr>; 
    $$ = Vec::new() 
  }
  ;

SExpr
  : '(' BEGIN ExpressionsList ')' {
    |$3: Vec<Expr>| -> Expr;
    $$ = Expr::BlockStatement($3)
  }
  | '(' IDENTIFIER ExpressionsList ')' {
    |$2: Token, $3: Vec<Expr>| -> Expr;
    $$ = Expr::CallExpression($2.value.to_string(), $3)
  }
  | '(' VAR IDENTIFIER Expression ')' {
    |$3: Token, $4: Expr| -> Expr;
    $$ = Expr::VariableDeclaration($3.value.to_string(), Box::new($4))
  }
  | '(' IF Expression Expression Expression ')' {
    |$3: Expr, $4: Expr, $5: Expr| -> Expr;
    $$ = Expr::IfExpression(Box::new($3), Box::new($4), Box::new($5))
  }
  | '(' WHILE Expression Expression ')' {
    |$3: Expr, $4: Expr| -> Expr;
    $$ = Expr::WhileStatement(Box::new($3), Box::new($4))
  }
  | '(' ASSIGN IDENTIFIER Expression ')' {
    |$3: Token, $4: Expr| -> Expr;
    $$ = Expr::Assignment($3.value.to_string(), Box::new($4))
  }
  | '(' OPERATOR Expression Expression ')' {
    |$2: Token, $3: Expr, $4: Expr| -> Expr;
    $$ = Expr::BinaryExpression($2.value.to_string(), Box::new($3), Box::new($4))
  }
  ;

